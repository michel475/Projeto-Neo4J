Key statement
CYPHER 5 CREATE CONSTRAINT `id_Comunidade_uniq` IF NOT EXISTS
FOR (n: `Comunidade`)
REQUIRE (n.`id`) IS UNIQUE;
Load statement
CYPHER 5 UNWIND $nodeRecords AS nodeRecord
WITH *
WHERE NOT nodeRecord.`id` IN $idsToSkip AND NOT toInteger(trim(nodeRecord.`id`)) IS NULL
MERGE (n: `Comunidade` { `id`: toInteger(trim(nodeRecord.`id`)) })
SET n.`nome` = nodeRecord.`nome`;


CYPHER 5 CREATE CONSTRAINT `id_Comentario_uniq` IF NOT EXISTS
FOR (n: `Comentario`)
REQUIRE (n.`id`) IS UNIQUE;
Load statement
CYPHER 5 UNWIND $nodeRecords AS nodeRecord
WITH *
WHERE NOT nodeRecord.`id` IN $idsToSkip AND NOT toInteger(trim(nodeRecord.`id`)) IS NULL
MERGE (n: `Comentario` { `id`: toInteger(trim(nodeRecord.`id`)) })
SET n.`conteudo` = nodeRecord.`conteudo`
SET n.`n_curtidas` = toLower(trim(nodeRecord.`n_curtidas`)) IN ['1','true','yes'];



// NOTE: The following script syntax is valid for database version 5.0 and above.

:param {
  // Define the file path root and the individual file names required for loading.
  // https://neo4j.com/docs/operations-manual/current/configuration/file-locations/
  file_path_root: 'file:///', // Change this to the folder your script can access the files at.
  file_0: 'insercao_data - PÃ¡gina1.csv'
};

// CONSTRAINT creation
// -------------------
//
// Create node uniqueness constraints, ensuring no duplicates for the given node label and ID property exist in the database. This also ensures no duplicates are introduced in future.
//
CREATE CONSTRAINT `data_data_uniq` IF NOT EXISTS
FOR (n: `data`)
REQUIRE (n.`data`) IS UNIQUE;

:param {
  idsToSkip: []
};

// NODE load
// ---------
//
// Load nodes in batches, one node label at a time. Nodes will be created using a MERGE statement to ensure a node with the same label and ID property remains unique. Pre-existing nodes found by a MERGE statement will have their other properties set to the latest values encountered in a load file.
//
// NOTE: Any nodes with IDs in the 'idsToSkip' list parameter will not be loaded.
LOAD CSV WITH HEADERS FROM ($file_path_root + $file_0) AS row
WITH row
WHERE NOT row.`data` IN $idsToSkip AND NOT row.`data` IS NULL
CALL (row) {
  MERGE (n: `data` { `data`: row.`data` })
  SET n.`data` = row.`data`
} IN TRANSACTIONS OF 10000 ROWS;


// RELATIONSHIP load
// -----------------
//
// Load relationships in batches, one relationship type at a time. Relationships are created using a MERGE statement, meaning only one relationship of a given type will ever be created between a pair of nodes.
